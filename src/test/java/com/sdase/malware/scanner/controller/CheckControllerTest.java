package com.sdase.malware.scanner.controller;

import static org.hamcrest.Matchers.endsWith;
import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.is;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.header;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.util.ArrayList;
import java.util.List;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.mongodb.MongoException;
import com.sdase.malware.scanner.exception.NotProcessedException;
import com.sdase.malware.scanner.exception.PreValidationException;
import com.sdase.malware.scanner.exception.handler.ResourceExceptionHandler;
import com.sdase.malware.scanner.service.CheckService;
import com.sdase.malware.scanner.streaming.model.CheckEvent;
import com.sdase.malware.scanner.streaming.model.CheckResultEvent;
import com.sdase.malware.scanner.streaming.model.CheckResultEvent.StateEnum;
import com.sdase.malware.scanner.utils.TestUtils;

@SpringBootTest
@ExtendWith(SpringExtension.class)
class CheckControllerTest {

	private static final String URL = "/check";
	private static final String BY_ID = URL.concat("/abcd");
	private MockMvc mockMvc;
	private AutoCloseable closeable;
	
	@MockBean
	private CheckService checkService;
	
	@InjectMocks
	private CheckController checkController;
	
	@BeforeEach
	void setUp() {
		this.mockMvc = MockMvcBuilders.standaloneSetup(checkController)
				.setControllerAdvice(new ResourceExceptionHandler()).build();
		closeable = MockitoAnnotations.openMocks(this);
	}
	
	@AfterEach
	void releaseMocks() throws Exception {
		closeable.close();
	}
	
	@Test
	void checkRequestPreValidationExceptionTest() throws Exception {
		when(checkService.saveCheckRequest(any(CheckEvent.class))).thenThrow(new PreValidationException("File not found", null));
		this.mockMvc
		.perform(post(URL).content(new ObjectMapper().writeValueAsString(TestUtils.buildCheckEvent("/test")))
				.contentType(MediaType.APPLICATION_JSON))
		.andExpect(status().isUnprocessableEntity())
		.andExpect(jsonPath("state", is("IGNORED")))
		.andExpect(jsonPath("name", is("pre-validation")))
		.andExpect(jsonPath("details", is("File not found")));
	}
	
	@Test
	void checkRequestGeneralExceptionTest() throws Exception {
		when(checkService.saveCheckRequest(any(CheckEvent.class))).thenThrow(new MongoException("Error while connecting to the database"));
		this.mockMvc
		.perform(post(URL).content(new ObjectMapper().writeValueAsString(TestUtils.buildCheckEvent("/test")))
				.contentType(MediaType.APPLICATION_JSON))
		.andExpect(status().isInternalServerError())
		.andExpect(jsonPath("state", is("ERROR")))
		.andExpect(jsonPath("name", is("error")))
		.andExpect(jsonPath("details", is("Error while connecting to the database")));
	}
	
	@Test
	void checkRequestSuccessTest() throws Exception {
		when(checkService.saveCheckRequest(any(CheckEvent.class))).thenReturn("abcd");
		this.mockMvc
		.perform(post(URL).content(new ObjectMapper().writeValueAsString(TestUtils.buildCheckEvent("/test")))
				.contentType(MediaType.APPLICATION_JSON))
		.andExpect(status().isAccepted()).andExpect(header().exists("location"))
		.andExpect(header().string("location", endsWith(BY_ID)));
	}
	
	@Test
	void getCheckResultNotFinishedTest() throws Exception {
		when(checkService.getCheckResult("abcd")).thenThrow(new NotProcessedException("abcd"));
		this.mockMvc
		.perform(get(BY_ID).contentType(MediaType.APPLICATION_JSON))
		.andExpect(status().isNotFound());
	}
	
	@Test
	void getCheckResultSuccessTest() throws Exception {
		when(checkService.getCheckResult("abcd")).thenReturn(TestUtils.buildCheckResultEvents());
		this.mockMvc
		.perform(get(BY_ID).contentType(MediaType.APPLICATION_JSON))
		.andExpect(status().isOk())
		.andExpect(jsonPath("$", hasSize(2)))
		.andExpect(jsonPath("$.[0].state", is("OK")))
		.andExpect(jsonPath("$.[0].name", is("iban-checker")))
		.andExpect(jsonPath("$.[0].details", is("This file has a valid IBAN code")))
		.andExpect(jsonPath("$.[1].state", is("ERROR")))
		.andExpect(jsonPath("$.[1].name", is("other-checker")))
		.andExpect(jsonPath("$.[1].details", is("This file has an error")));
		
		List<CheckResultEvent> response = new ArrayList<>();
		response.add(new CheckResultEvent(StateEnum.OK, "iban-checker", "This file has a valid IBAN code"));
		response.add(new CheckResultEvent(StateEnum.ERROR, "other-checker", "This file has an error"));
	}
	
	
}
